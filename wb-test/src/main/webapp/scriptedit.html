<html>

<body>

<style>
	body {
		margin: 0px;
		padding: 0px;
	}
	canvas {
		border: 1px solid #9C9898;
	}
	.progress {
		display: none;
	}
	
	#Editor {
		width: 1000px;
	}
	
	#BoardPane {
		float: left; 
		width: 600px;
	}
	
	#EpisodesPane {
		float: right; 
		width: 390px;
		border: 1px solid blue;
	}
	
	#AddNewEpisodePane {
		padding: 10px;
	}
	
	a.action img {
		vertical-align: bottom;
	}
	
	.EpisodeType {
		border: 1px solid #eee;
		margin: 4px;
		-webkit-border-radius: 3px;
		-moz-border-radius: 3px;
		border-radius: 3px;
		cursor: pointer;
	}

	.EpisodeType:hover {
		background-color: whiteSmoke;
	}

	.EpisodeType .Icon {
		float: left;
		margin: 2px;
	}

	.EpisodeType .Icon img {
		max-width: 50px;
		max-height: 50px;
	}

	.EpisodeType .Desc {
		margin-left: 55px;
		margin-top: 10px;
	}
	
	.Episode {
		border: 1px solid #eee;
		margin: 4px;
		-webkit-border-radius: 3px;
		-moz-border-radius: 3px;
		border-radius: 3px;
		cursor: pointer;
		min-height: 40px;
		padding: 4px;
	}

	.Episode:hover {
		background-color: whiteSmoke;
	}

	.Episode.selected {
		background-color: whiteSmoke;
		margin: 10px;
	}

	.Episode .Icon {
		float: left;
		margin: 2px;
	}

	.Episode .Icon img {
		float: left;
		margin: 2px;
		max-width: 50px;
		max-height: 50px;
	}
	
	.Episode .Desc {
		margin-left: 55px;
		margin-top: 10px;
	}
	
	#EpisodesPane {
		max-height: 500px;
		overflow-y: auto;
	}
	
	#EpisodesPane::-webkit-scrollbar-track {
		-webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.3);
		border-radius: 10px;
	}
	
</style>

    <script src="kinetic-v3.10.5.js"></script>

	<div id="Editor">
	
		<div id="BoardPane">
			<div id="Board">
			</div>
		</div>
		
		<div id="EpisodesPane">
		
			<div id="EpisodeList">
			</div>
			
			<div id="AddNewEpisodePane">
				
				<div>Samples:</div>
				<div>
					<a class="AddACar">Add a car</a>
				</div>
				<div style="margin-bottom: 10px;"></div>
			
				<a class="AddNewEpisodeAction action">
					<img src="images/add.png"/>
					Add New Episode
				</a>
			</div>
		</div>
		
		<div style="clear: both;"></div>
	</div>
	
	<div id="dialogs" style="display: block;">
	
		<div id="NewEpisodeDialog" title="Episode" style="border: 1px solid gray; width: 360px;">
			<div id="NewEpisodeDialog-SelectType">
			    <div>Select a type of episode:</div>
			    
			    <div class="EpisodeType BasicShape" data-type="BasicShape">
			    	<div class="Icon">
				    	<img src="images/shapes.png"/>
			    	</div>
			    	<div class="Desc">
			    		A simple shape such as a rectangle or an oval 
			    	</div>
			    	<div style="clear: both;"></div>
			    </div>

			    <div class="EpisodeType Line" data-type="Line">
			    	<div class="Icon">
				    	<img src="images/arrow_right.png"/>
			    	</div>
			    	<div class="Desc">
			    		A line or an arrow 
			    	</div>
			    	<div style="clear: both;"></div>
			    </div>

			    <div class="EpisodeType Shape" data-type="Shape">
			    	<div class="Icon">
				    	<img src="images/image.png"/>
			    	</div>
			    	<div class="Desc">
			    		A drawing from the gallery
			    	</div>
			    	<div style="clear: both;"></div>
			    </div>
			    
			    <div class="EpisodeType Math" data-type="Math">
			    	<div class="Icon" style="margin-left: 10px;">
				    	<img src="images/formula32.png"/>
			    	</div>
			    	<div class="Desc">
			    		A formula
			    	</div>
			    	<div style="clear: both;"></div>
			    </div>
			    
			    <div class="EpisodeType Text" data-type="Text">
			    	<div class="Icon">
				    	<img src="images/quill.png"/>
			    	</div>
			    	<div class="Desc">
			    		Text 
			    	</div>
			    	<div style="clear: both;"></div>
			    </div>
			    
			    <div class="EpisodeType Speech" data-type="Speech">
			    	<div class="Icon">
				    	<img src="images/microphone.png"/>
			    	</div>
			    	<div class="Desc">
			    		Speak
			    	</div>
			    	<div style="clear: both;"></div>
			    </div>
			    
			    <div class="EpisodeType Pan" data-type="Pan">
			    	<div class="Icon">
				    	<img src="images/compass.png"/>
			    	</div>
			    	<div class="Desc">
			    		Pan board
			    	</div>
			    	<div style="clear: both;"></div>
			    </div>
			    
			    <div class="EpisodeType Pause" data-type="Pause">
			    	<div class="Icon">
				    	<img src="images/pause.png"/>
			    	</div>
			    	<div class="Desc">
			    		A pause
			    	</div>
			    	<div style="clear: both;"></div>
			    </div>
			</div>
		</div>
		
	</div>

	<div id="templates" style="display: none;">
		<div id="ShapeEpisodeView" class="Episode Shape">
			<!-- xxx -->
			<div class="Icon">
				<img/>
			</div>
			<div class="Desc">
				still working on this...
			</div>
			<div style="clear: both;"></div>
		</div>
	</div>
	
	<script type="text/javascript">

	    var stage = new Kinetic.Stage({
	        container: "Board",
	        width: 592,
	        height: 333
	      });
	
	    var layer = new Kinetic.Layer();
	    stage.add(layer);

        stage.start();

        var WBShapeAdapter = Kinetic.Shape.extend({
        	
            init: function(config) {
                this.setDefaultAttrs({
                    width: 0,
                    height: 0,
                    cornerRadius: 0
                });
                this.shapeType = "WB";
                config.drawFunc = this.drawFunc;
                // call super constructor
                this._super(config);
                
                this.shape = config.shape;
            },
            
            _draw: function(canvas) {
                var stage = this.getStage();
                var context = canvas.getContext();
                var family = [];
                var parent = this.parent;

                family.unshift(this);
                while(parent) {
                    family.unshift(parent);
                    parent = parent.parent;
                }

                context.save();
                
                var tr = new WB.Transform();
                for(var n = 0; n < family.length; n++) {
                    var node = family[n];
                    var t = node.getTransform();
                    var m = t.getMatrix();
                    tr.multiply({m: m});
                }

                /*
                 * pre styles include alpha, linejoin
                 */
                var absAlpha = this.getAbsoluteAlpha();
                if(absAlpha !== 1) {
                    context.globalAlpha = absAlpha;
                }
                this.applyLineJoin(context);

                // draw the shape
                this.appliedShadow = false;
                this.doDraw(canvas, context, tr);
                
                context.restore();
            },
            
            doDraw: function(canvas, context, defaultTransform) {
            	
				var pane = new WB.Pane({canvas: canvas, defaultTransform: defaultTransform});
				
				/*
		        context.beginPath();
        	    context.rect(0, 0, this.attrs.width, this.attrs.height);
                context.closePath();
	
				//this.fill(context);
				this.stroke(context);
				*/
				
				var shape = this.shape;

				var tr = new WB.Transform();
				//tr.translate(this.attrs.x, this.attrs.y);
				if (shape.localBounds) {
					var dWidth = this.attrs.width;
					var dHeight = this.attrs.height;
					var lWidth = Math.abs(shape.localBounds.bottomright.x - shape.localBounds.topleft.x);
					var lHeight = Math.abs(shape.localBounds.bottomright.y - shape.localBounds.topleft.y);
					var scaleX = 1.0;
					var scaleY = 1.0;
					if (Math.abs(dWidth - lWidth) > 1e-2) {
						scaleX = dWidth / lWidth;
					}
					if (Math.abs(dHeight - lHeight) > 1e-2) {
						scaleY = dHeight / lHeight;
					}
					tr.scale(scaleX, scaleY);

					// compensate
					tr.translate(-shape.localBounds.topleft.x, 
							-shape.localBounds.topleft.y);

					// center
					var dx = (dWidth - lWidth * scaleX) / 2;
					var dy = (dHeight - lHeight * scaleY) / 2;
					tr.translate(dx/scaleX, dy/scaleY);
				}

				var group = new WB.GroupShape({transform: tr, shapes: [shape]});
				group.draw(pane);
			},
			
			/*
			// TODO: intersects to detect with the box? or provide a big box around?
		    intersects: function() {
		        var pos = Kinetic.Type._getXY(Array.prototype.slice.call(arguments));
		        var stage = this.getStage();

                var family = [];
                var parent = this.parent;

                family.unshift(this);
                while(parent) {
                    family.unshift(parent);
                    parent = parent.parent;
                }
                
                var tr = new WB.Transform();
                for(var n = 0; n < family.length; n++) {
                    var node = family[n];
                    var t = node.getTransform();
                    var m = t.getMatrix();
                    tr.multiply({m: m});
                }
                
                var xy = tr.transformPoint(0, 0);
                var x = xy.x;
                var y = xy.y;
				var width = this.attrs.width;
				var height = this.attrs.height;
		        
		        return pox.x >= x && pos.x <= x + width
		        		&& pos.y >= y && pos.y <= y + height;
		    },
		    */
			
		    setSize: function() {
		        var size = Kinetic.Type._getSize(Array.prototype.slice.call(arguments));
		        this.setAttrs(size);
		    },
		    
		    getSize: function() {
		        return {
		            width: this.attrs.width,
		            height: this.attrs.height
		        };
		    }
		});
        
        
		function update(group, activeAnchor) {
			var topLeft = group.get(".topLeft")[0];
			var topRight = group.get(".topRight")[0];
			var bottomRight = group.get(".bottomRight")[0];
			var bottomLeft = group.get(".bottomLeft")[0];
			var image = group.get(".image")[0];
			var frame = group.get(".frame")[0];
			
			// update anchor positions
			switch (activeAnchor.getName()) {
				case "topLeft":
					topRight.attrs.y = activeAnchor.attrs.y;
					bottomLeft.attrs.x = activeAnchor.attrs.x;
					break;
				case "topRight":
					topLeft.attrs.y = activeAnchor.attrs.y;
					bottomRight.attrs.x = activeAnchor.attrs.x;
					break;
				case "bottomRight":
					bottomLeft.attrs.y = activeAnchor.attrs.y;
					topRight.attrs.x = activeAnchor.attrs.x;
					break;
				case "bottomLeft":
					bottomRight.attrs.y = activeAnchor.attrs.y;
					topLeft.attrs.x = activeAnchor.attrs.x;
					break;
			}
			
			image.setPosition(topLeft.attrs.x, topLeft.attrs.y);
			frame.setPosition(topLeft.attrs.x, topLeft.attrs.y);
			
			var width = topRight.attrs.x - topLeft.attrs.x;
			var height = bottomLeft.attrs.y - topLeft.attrs.y;
			if (width && height) {
				image.setSize(width, height);
				frame.setSize(width, height);
			}
		}

		function addAnchor(group, x, y, name) {
			var stage = group.getStage();
			var layer = group.getLayer();
			
			var anchor = new Kinetic.Circle({
				x: x,
				y: y,
				stroke: "#666",
				fill: "#ddd",
				strokeWidth: 2,
				radius: 8,
				name: name,
				draggable: true
			});
			
			anchor.on("dragmove", function() {
				update(group, this);
				layer.draw();
			});
			anchor.on("mousedown touchstart", function() {
				group.setDraggable(false);
				this.moveToTop();
			});
			anchor.on("dragend", function() {
				group.setDraggable(true);
				layer.draw();
			});
			
			// add hover styling
			anchor.on("mouseover", function(e) {
				var layer = this.getLayer();
				document.body.style.cursor = 'pointer';
				e.cancelBubble = true;
				this.setStrokeWidth(4);
				layer.draw();
			});
			anchor.on("mousemove", function(e) {
				document.body.style.cursor = 'pointer';
				e.cancelBubble = true;
			});
			anchor.on("mouseout", function(e, a, b, c) {
				var layer = this.getLayer();
				var inter = group.getIntersections({x: e.x, y: e.y});
				if (inter && inter.length) {
					document.body.style.cursor = 'move';
				} else {
					document.body.style.cursor = 'default';
				}
				this.setStrokeWidth(2);
				layer.draw();
			});
			
			group.add(anchor);
		}
	    
		function showShape(shape) {
			console.log('showShape:');
			console.log(shape);
			
			// pick initial size
			var dWidth = 200;
			var dHeight = 200;
			var width = dWidth;
			var height = dHeight;
			if (shape.localBounds) {
				width = Math.abs(shape.localBounds.bottomright.x - shape.localBounds.topleft.x);
				height = Math.abs(shape.localBounds.bottomright.y - shape.localBounds.topleft.y);
				// w/h: 200 vs 295; 200 vs 132
				console.log('w/h: ' + dWidth + ' vs ' + width + '; ' + dHeight + ' vs ' + height);
				var scaleX = 1.0;
				var scaleY = 1.0;
				if (Math.abs(dWidth - width) > 1e-2) {
					scaleX = dWidth / width;
				}
				if (Math.abs(dHeight - height) > 1e-2) {
					scaleY = dHeight / height;
				}
				var scale = Math.min(scaleX, scaleY);
				// scale: 0.6779661016949152
				console.log('scale: ' + scale);
				
				width *= scale;
				height *= scale;
				console.log('w/h: ' + width + ' x ' + height);
			}
			
			var group = new Kinetic.Group({
				x: Math.max(Math.round(Math.random() * stage.attrs.width) - width, 10),
				y: Math.max(Math.round(Math.random() * stage.attrs.height) - height, 10),
				draggable: true
			});
			layer.add(group);

	        var frame = new Kinetic.Rect({
				x: 0,
				y: 0,
				width: width,
				height: height,
				stroke: "black",
				strokeWidth: 2,
				name: "frame"
	        });
			group.add(frame);

			var image = new WBShapeAdapter({
				x: 0,
				y: 0,
				width: width,
				height: height,
				stroke: "black",
				strokeWidth: 2,
				name: "image",
				shape: shape
			});
			group.add(image);

			// mouseover
	        group.on("mousemove", function(e) {
				document.body.style.cursor = 'move';
	        });
	        group.on("mouseout", function() {
				document.body.style.cursor = 'default';
	        });       

			addAnchor(group, 0, 0, "topLeft");
	        addAnchor(group, width, 0, "topRight");
	        addAnchor(group, width, height, "bottomRight");
	        addAnchor(group, 0, height, "bottomLeft");
			
	        group.on("dragstart", function() {
				//this.moveToTop();
			});
		
			stage.draw();
		}
	
		function downloadAndShowShape(path) {
			console.log('downloadAndShowShape: ' + path);
			$.ajax({url: path, contentType: 'application/json'})
			.done(function(json) {
				console.log('got data');
				if (json) {
					if (json.constructor == String) {
						json = JSON.parse(json);
					}
					console.log(json);
					
					var parser = new WB.Parser();
					var shape = parser.parse(json);
					showShape(shape);
				}
			});
		}
		
		$('a.AddACar').click(function() {
			// xxx
			var model = new Episode({
				_type: 'Shape',
				id: 'openclipart_org-car-outline-modified-by-molumen-' + episodeListModel.length,
				title: 'A car',
				thumbUrl: '/wb/shapedb/openclipart_org-car-outline-modified-by-molumen.png' 
			});
			
			episodeListModel.add(model);
			episodeListView.select(model);
			
			downloadAndShowShape('shapedb/openclipart_org-car-outline-modified-by-molumen.json');
			
			//$('.Episode.selected').toggleClass('selected', false);
			//this.$el.toggleClass('selected', true);
			
			var offset = $('a.AddNewEpisodeAction').offset();
			offset.left -= 20;
			offset.top -= 20;
			
			$('#EpisodesPane').animate({
			    scrollTop: offset.top,
			    scrollLeft: offset.left
			});
		});
        
	</script>

	<script type="text/javascript">
	
		var Episode = Backbone.Model.extend({
			remove: function() {
				this.destroy();
			}
		});
	
		var EpisodeList = Backbone.Collection.extend({
			
			model: Episode,
			
			comparator: function(episode) {
				return episode.get('seq');
			}
			
		});
		
		var BaseEpisodeView = Backbone.View.extend({
			
			tagName: "div",
			className: "Episode",
			
			events: {
				'click': 'select'
			},

			initialize: function() {
				this.model.bind('destroy', this.remove, this);
			},			
			
			render: function() {
				var model = this.model.toJSON();
				// console.log('render: ' + JSON.stringify(model));

				/*
				this.$el.html(this.skeleton);
				
				this.$el.find('div.Title').text(model.title);
				if (model.source) {
					this.$el.find('div.Source').text(model.source);
				}
				this.$el.find('div.Thumb img').attr('src', '/wb/episode/' + model.id + '.png');
				*/
				
				return this;
			},
			
			select: function(e) {
				console.log('select');
				if (e) {
					e.stopPropagation();
				}
				/*
				episodeDetailApp.setEpisode(this.model);
				*/
				$('.Episode.selected').toggleClass('selected', false);
				this.$el.toggleClass('selected', true);
			}
			
		});

		var ShapeEpisodeView = BaseEpisodeView.extend({
			
			className: "Episode Shape",
			
			skeleton: $('#ShapeEpisodeView').html(),
			
			render: function() {
				var model = this.model.toJSON();
				// console.log('render: ' + JSON.stringify(model));
				
				this.$el.html(this.skeleton);
				
				this.$el.find('div.Icon img').attr('src', model.thumbUrl);

				// xxx

				/*
				this.$el.find('div.Title').text(model.title);
				if (model.source) {
					this.$el.find('div.Source').text(model.source);
				}
				this.$el.find('div.Thumb img').attr('src', '/wb/episode/' + model.id + '.png');
				*/
				
				return this;
			},
			
		});

		
		var EpisodeListView = Backbone.View.extend({
			el: $('#EpisodesPane'),
			
			initialize: function() {
				this.model.bind('add', this.addOne, this);
				this.model.bind('reset', this.reAddAll, this);
				
				this.$listEl = this.$el.find('#EpisodeList');
				
				var that = this;
				
				this.$el.find('a.AddNewEpisodeAction').button();
				this.$el.find('a.AddNewEpisodeAction').click(function() {
					that.newEpisodeAction();
				});
				
				$('#NewEpisodeDialog').dialog({
					autoOpen: false,
					closeOnEscape: true
				});
				$('#NewEpisodeDialog div.EpisodeType').click(function() {
					that.episodeTypeSelected($(this).data('type'));
				});
				
				this.views = [];
			},

			render: function() {
				return this;
			},
			
			reAddAll: function() {
				this.views = [];
				this.$listEl.html('');
				this.model.each(this.addOne, this);
			},			
			
			getViewClass: function(type) {
				if (type == 'Shape') {
					return ShapeEpisodeView;
				}
				return BaseEpisodeView;
			},
			
			addOne: function(model) {
				var viewClass = this.getViewClass(model.get('_type'));
				var view = new viewClass({model: model});
				this.$listEl.append(view.render().el);
				this.views.push(view);
			},
			
			newEpisodeAction: function() {
				console.log('new episode!');
				$('#NewEpisodeDialog').dialog('open');
			},
			
			episodeTypeSelected: function(type) {
				console.log('selected type: ' + type);
			},
			
			select: function(model) {
				for (var i = 0; i < this.views.length; i++) {
					var view = this.views[i];
					if (view.model.id === model.id) {
						view.select();
					}
				}
			}
			
		});
		
		
		episodeListModel = new EpisodeList();
		episodeListView = new EpisodeListView({model: episodeListModel});
		
	</script>
	
</body>
</html>
